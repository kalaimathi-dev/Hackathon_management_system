const Hackathon = require('../models/Hackathon');
const User = require('../models/User');
const AuditLog = require('../models/AuditLog');
const { getClientIp } = require('../utils/helpers');

const createHackathon = async (req, res) => {
  try {
    const {
      title,
      description,
      startDate,
      endDate,
      assignmentStartDate,
      assignmentEndDate,
      submissionDeadline,
      maxParticipants,
      tasksPerParticipant,
      allowPublicRegistration
    } = req.body;

    // Validation
    if (new Date(endDate) <= new Date(startDate)) {
      return res.status(400).json({
        success: false,
        message: 'End date must be after start date'
      });
    }

    if (new Date(assignmentEndDate) <= new Date(assignmentStartDate)) {
      return res.status(400).json({
        success: false,
        message: 'Assignment end date must be after assignment start date'
      });
    }

    if (new Date(submissionDeadline) <= new Date(assignmentEndDate)) {
      return res.status(400).json({
        success: false,
        message: 'Submission deadline must be after assignment end date'
      });
    }

    const hackathon = new Hackathon({
      title,
      description,
      startDate,
      endDate,
      assignmentStartDate,
      assignmentEndDate,
      submissionDeadline,
      maxParticipants: maxParticipants || 100,
      tasksPerParticipant: tasksPerParticipant || 1,
      allowPublicRegistration: allowPublicRegistration !== undefined ? allowPublicRegistration : true,
      createdBy: req.user._id
      // registrationCode will be auto-generated by pre-save hook
    });

    await hackathon.save();

    await AuditLog.create({
      action: 'hackathon_created',
      performedBy: req.user._id,
      hackathonId: hackathon._id,
      ipAddress: getClientIp(req)
    });

    res.status(201).json({
      success: true,
      message: 'Hackathon created successfully',
      data: { 
        hackathon,
        registrationUrl: hackathon.getRegistrationUrl()
      }
    });
  } catch (error) {
    console.error('Create hackathon error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create hackathon'
    });
  }
};

const getAllHackathons = async (req, res) => {
  try {
    const { status } = req.query;
    const filter = status ? { status } : {};

    const hackathons = await Hackathon.find(filter)
      .populate('createdBy', 'name email')
      .sort({ createdAt: -1 });

    // Add registration URLs to each hackathon
    const hackathonsWithUrls = hackathons.map(h => ({
      ...h.toObject(),
      registrationUrl: h.getRegistrationUrl()
    }));

    res.json({
      success: true,
      data: { hackathons: hackathonsWithUrls }
    });
  } catch (error) {
    console.error('Get hackathons error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch hackathons'
    });
  }
};

const getHackathonById = async (req, res) => {
  try {
    const hackathon = await Hackathon.findById(req.params.id)
      .populate('createdBy', 'name email')
      .populate('participants', 'name email skills')
      .populate('judges', 'name email');

    if (!hackathon) {
      return res.status(404).json({
        success: false,
        message: 'Hackathon not found'
      });
    }

    res.json({
      success: true,
      data: { 
        hackathon: {
          ...hackathon.toObject(),
          registrationUrl: hackathon.getRegistrationUrl()
        }
      }
    });
  } catch (error) {
    console.error('Get hackathon error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch hackathon'
    });
  }
};

const updateHackathon = async (req, res) => {
  try {
    const hackathon = await Hackathon.findById(req.params.id);

    if (!hackathon) {
      return res.status(404).json({
        success: false,
        message: 'Hackathon not found'
      });
    }

    const allowedUpdates = [
      'title',
      'description',
      'startDate',
      'endDate',
      'assignmentStartDate',
      'assignmentEndDate',
      'submissionDeadline',
      'status',
      'maxParticipants',
      'tasksPerParticipant',
      'allowPublicRegistration'
    ];

    allowedUpdates.forEach(field => {
      if (req.body[field] !== undefined) {
        hackathon[field] = req.body[field];
      }
    });

    await hackathon.save();

    await AuditLog.create({
      action: 'hackathon_updated',
      performedBy: req.user._id,
      hackathonId: hackathon._id,
      details: req.body,
      ipAddress: getClientIp(req)
    });

    res.json({
      success: true,
      message: 'Hackathon updated successfully',
      data: { 
        hackathon: {
          ...hackathon.toObject(),
          registrationUrl: hackathon.getRegistrationUrl()
        }
      }
    });
  } catch (error) {
    console.error('Update hackathon error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update hackathon'
    });
  }
};

const deleteHackathon = async (req, res) => {
  try {
    const hackathon = await Hackathon.findById(req.params.id);

    if (!hackathon) {
      return res.status(404).json({
        success: false,
        message: 'Hackathon not found'
      });
    }

    await hackathon.deleteOne();

    await AuditLog.create({
      action: 'hackathon_deleted',
      performedBy: req.user._id,
      hackathonId: hackathon._id,
      ipAddress: getClientIp(req)
    });

    res.json({
      success: true,
      message: 'Hackathon deleted successfully'
    });
  } catch (error) {
    console.error('Delete hackathon error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete hackathon'
    });
  }
};

const enrollParticipant = async (req, res) => {
  try {
    const hackathon = await Hackathon.findById(req.params.id);

    if (!hackathon) {
      return res.status(404).json({
        success: false,
        message: 'Hackathon not found'
      });
    }

    if (hackathon.status !== 'active') {
      return res.status(400).json({
        success: false,
        message: 'Cannot enroll in inactive hackathon'
      });
    }

    if (hackathon.participants.includes(req.user._id)) {
      return res.status(400).json({
        success: false,
        message: 'Already enrolled in this hackathon'
      });
    }

    if (hackathon.participants.length >= hackathon.maxParticipants) {
      return res.status(400).json({
        success: false,
        message: 'Hackathon is full'
      });
    }

    hackathon.participants.push(req.user._id);
    await hackathon.save();

    await AuditLog.create({
      action: 'participant_enrolled',
      performedBy: req.user._id,
      hackathonId: hackathon._id,
      ipAddress: getClientIp(req)
    });

    res.json({
      success: true,
      message: 'Enrolled successfully'
    });
  } catch (error) {
    console.error('Enroll error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to enroll'
    });
  }
};

// PUBLIC: Get hackathon by registration code (No auth required)
const getHackathonByCode = async (req, res) => {
  try {
    const { code } = req.params;

    const hackathon = await Hackathon.findOne({ registrationCode: code })
      .select('-__v')
      .populate('createdBy', 'name');

    if (!hackathon) {
      return res.status(404).json({
        success: false,
        message: 'Invalid registration link'
      });
    }

    // Return limited hackathon info for public view
    res.json({
      success: true,
      data: { 
        hackathon: {
          _id: hackathon._id,
          title: hackathon.title,
          description: hackathon.description,
          startDate: hackathon.startDate,
          endDate: hackathon.endDate,
          submissionDeadline: hackathon.submissionDeadline,
          maxParticipants: hackathon.maxParticipants,
          currentParticipants: hackathon.participants?.length || 0,
          status: hackathon.status,
          allowPublicRegistration: hackathon.allowPublicRegistration,
          isRegistrationOpen: hackathon.isRegistrationOpen(),
          createdBy: hackathon.createdBy
        }
      }
    });
  } catch (error) {
    console.error('Get hackathon by code error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch hackathon details'
    });
  }
};

// PUBLIC: Register via public link (No auth required)
const registerViaLink = async (req, res) => {
  try {
    const { code } = req.params;
    const { name, email, password, skills } = req.body;

    console.log('=== Registration Via Link Started ===');
    console.log('Code:', code);
    console.log('Email:', email);
    console.log('Name:', name);

    // Validate required fields
    if (!name || !email || !password) {
      console.log('Validation failed: Missing required fields');
      return res.status(400).json({
        success: false,
        message: 'Name, email, and password are required'
      });
    }

    // Validate password length
    if (password.length < 6) {
      console.log('Validation failed: Password too short');
      return res.status(400).json({
        success: false,
        message: 'Password must be at least 6 characters long'
      });
    }

    // Find hackathon by code
    const hackathon = await Hackathon.findOne({ registrationCode: code });

    if (!hackathon) {
      console.log('Hackathon not found for code:', code);
      return res.status(404).json({
        success: false,
        message: 'Invalid registration link'
      });
    }

    console.log('Hackathon found:', hackathon.title);

    // Check if registration is open
    const registrationOpen = hackathon.isRegistrationOpen();
    console.log('Registration open:', registrationOpen);
    
    if (!registrationOpen) {
      const reason = !hackathon.allowPublicRegistration ? 'Public registration is disabled' :
                     hackathon.status !== 'active' && hackathon.status !== 'draft' ? `Hackathon status is ${hackathon.status}` :
                     new Date() > hackathon.startDate ? 'Hackathon has already started' :
                     hackathon.participants.length >= hackathon.maxParticipants ? 'Maximum participants reached' :
                     'Unknown reason';
      
      console.log('Registration closed:', reason);
      
      return res.status(400).json({
        success: false,
        message: `Registration is closed. ${reason}`
      });
    }

    // Check if user already exists
    let user = await User.findOne({ email: email.toLowerCase() });

    if (user) {
      console.log('Existing user found:', user.email);
      
      // User exists - check if already enrolled
      if (hackathon.participants.includes(user._id)) {
        console.log('User already enrolled');
        return res.status(400).json({
          success: false,
          message: 'You are already registered for this hackathon. Please login to continue.'
        });
      }

      // Enroll existing user
      hackathon.participants.push(user._id);
      await hackathon.save();
      console.log('Existing user enrolled successfully');

      await AuditLog.create({
        action: 'participant_registered_via_link',
        performedBy: user._id,
        hackathonId: hackathon._id,
        ipAddress: getClientIp(req)
      });

      // Send welcome email (don't wait for it)
      const { sendWelcomeEmail } = require('../utils/emailService');
      sendWelcomeEmail(user, hackathon).catch(err => 
        console.error('Failed to send welcome email:', err)
      );

      return res.json({
        success: true,
        message: 'Successfully registered for the hackathon! Please login to continue.',
        data: { 
          user: {
            id: user._id,
            name: user.name,
            email: user.email
          },
          hackathon: {
            id: hackathon._id,
            title: hackathon.title
          }
        }
      });
    }

    console.log('Creating new user...');

    // Parse skills
    let skillsArray = [];
    if (skills) {
      if (Array.isArray(skills)) {
        skillsArray = skills;
      } else if (typeof skills === 'string') {
        skillsArray = skills.split(',').map(s => s.trim()).filter(s => s.length > 0);
      }
    }

    // Create new user (email verified by default for hackathon registration)
    user = new User({
      name,
      email: email.toLowerCase(),
      password,
      role: 'participant',
      skills: skillsArray,
      isEmailVerified: true // Auto-verify for hackathon registrations
    });

    await user.save();
    console.log('New user created:', user.email);

    // Enroll new user in hackathon
    hackathon.participants.push(user._id);
    await hackathon.save();
    console.log('User enrolled in hackathon');

    await AuditLog.create({
      action: 'new_user_registered_via_link',
      performedBy: user._id,
      hackathonId: hackathon._id,
      ipAddress: getClientIp(req)
    });

    // Send welcome email (don't wait for it)
    const { sendWelcomeEmail } = require('../utils/emailService');
    sendWelcomeEmail(user, hackathon).catch(err => 
      console.error('Failed to send welcome email:', err)
    );

    console.log('=== Registration Successful ===');

    res.status(201).json({
      success: true,
      message: 'Account created and registered for hackathon successfully! You can now login.',
      data: { 
        user: {
          id: user._id,
          name: user.name,
          email: user.email
        },
        hackathon: {
          id: hackathon._id,
          title: hackathon.title
        }
      }
    });

  } catch (error) {
    console.error('=== Registration Error ===');
    console.error('Error:', error.message);
    console.error('Stack:', error.stack);
    
    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: 'This email is already registered. Please login instead.'
      });
    }

    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map(err => err.message);
      return res.status(400).json({
        success: false,
        message: 'Validation error: ' + messages.join(', ')
      });
    }

    res.status(500).json({
      success: false,
      message: 'Registration failed. Please try again.'
    });
  }
};

// Regenerate registration code
const regenerateRegistrationCode = async (req, res) => {
  try {
    const hackathon = await Hackathon.findById(req.params.id);

    if (!hackathon) {
      return res.status(404).json({
        success: false,
        message: 'Hackathon not found'
      });
    }

    // Generate new code
    const crypto = require('crypto');
    hackathon.registrationCode = crypto.randomBytes(8).toString('hex');
    await hackathon.save();

    await AuditLog.create({
      action: 'registration_code_regenerated',
      performedBy: req.user._id,
      hackathonId: hackathon._id,
      ipAddress: getClientIp(req)
    });

    res.json({
      success: true,
      message: 'Registration link regenerated successfully',
      data: { 
        registrationCode: hackathon.registrationCode,
        registrationUrl: hackathon.getRegistrationUrl()
      }
    });
  } catch (error) {
    console.error('Regenerate code error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to regenerate registration link'
    });
  }
};

module.exports = {
  createHackathon,
  getAllHackathons,
  getHackathonById,
  updateHackathon,
  deleteHackathon,
  enrollParticipant,
  getHackathonByCode,
  registerViaLink,
  regenerateRegistrationCode
};